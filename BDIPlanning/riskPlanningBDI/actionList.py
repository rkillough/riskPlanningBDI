#This program parses a list of "assessed action tuples" which would hypothetically be a full list of utility ranked actions from an online planner, how this is generated by the online planner doesnt matter for now
#The program removes all AAs (assessed action tuples) with a utility below the T determined threshold and then removes all AAs with a risk value higher than that of the top ranked AA (by utility)

import random

n = 80		#number of random AAs to generate at start
T = 0.1	#utility tolerance threshold, this correspond to action's utilities needing to be within 5% of the top utility to make the list

class AssessedAction():
	action = ""
	utility = 0
	risk = 0
	def __init__(self, a, u, r):
		self.action = a
		self.utility = u
		self.risk = r 


def printList(L, length):
	for i,x in enumerate(L):
		print("x"+str(i)+": ("+x.action+", "+str(x.utility)+", "+str(x.risk)+")")

def sort(L):
    less = []
    equal = []
    greater = []

    if len(L) > 1:
        pivot = L[0]
        for x in L:
            if x.utility < pivot.utility:
                less.append(x)
            if x.utility == pivot.utility:
                equal.append(x)
            if x.utility > pivot.utility:
                greater.append(x)
        # Don't forget to return something!
        return sort(greater)+equal+sort(less)  # Just use the + operator to join lists
    # Note that you want equal ^^^^^ not pivot
    else:  # You need to hande the part at the end of the recursion - when you only have one element in your array, just return the array.
        return L

A = []
random.seed()

#generate a list of random utilities and risks 

for i in range(n):
	u = random.randint(0,1000)/1000
	r = random.randint(0,1000)/1000
	a = "a"+str(i)
	x = AssessedAction(a, u, r)
	A.append(x)

#printList(A, n)

#sort the list
A = sort(A)
print("List sorted by utility:")
printList(A, n)




#remove AAs not within the threshold	
B = []
for x in A:
	if(x.utility >= A[0].utility - (A[0].utility * T)):
		B.append(x)	
A = B

print("\nActions within the acceptable utility threshold:")
printList(A, n)

#remove AAs which have a higher risk than the next best AA
B = []
B.append(A[0]) 
for i in range(len(A)):
	if(i > 0):		#always include the best action
		if(A[i].risk < B[len(B)-1].risk):
			B.append(A[i])

A = B

print("\nRemoved redundant AAs where the risk was higher than the best utility anyway")
printList(A, n)


